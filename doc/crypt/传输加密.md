1. 通过/security/public_key 或者 /crypto/public_key 获取非对称加密公钥和算法名称，详情看ApiFox中的描述
2. 如何发起一个加密请求
   - 选择一个对称加密算法，用来对请求数据进行加密，支持的算法包括:
     - aes_ecb_pkcs7padding
     - aes_cbc_pkcs7padding
     - sm4_ecb_pkcs7padding
     - sm4_cbc_pkcs7padding
     - sm4_cfb
     - sm4_ofb
     - sm4_gcm
   - 客户端随机生成一个16字节的密钥key（客户自己保存好这个key，后续持续请求都会用到这个key来加密数据）
   - 通过选择的对称加密算法及生成的key加密请求数据，并且进行base64编码，最后http请求的body为：{"content":"加密及base64编码后数据"}
   - 把对应的对称加密算法放入请求的header中，示例：`X-CRYPT-SYMMETRY-ALGO: sm4_ecb_pkcs7padding`，后端就是根据这个header来判断当前请求是否是加密请求
   - 如果是登录请求，需要做的额外事情（主要是为了传输key密钥）
     - 根据第一步中获取公钥和非对称加密算法对key进行加密且base64编码，放入请求的header中，示例：`X-CRYPT-SYMMETRY-KEY: 经过加密的key`
     - 把第一步中返回的非对称加密算法放入header中，示例：`X-CRYPT-ASYMMETRIC-ALGO: sm2_pkcs8_c1c3c2`
   - 注意
     - 请求及响应是否加密，是根据请求头中是否存在`X-CRYPT-SYMMETRY-ALGO`，如果存在代表是加密请求，同理响应也会进行加密，并且也会携带`X-CRYPT-SYMMETRY-ALGO`返回
3. 如何更新加密密钥（之前说的key）
   - 背景
      - 客户端生成的这个key是客户端和服务端用来加解密共用的，除了在第一次登录的时候顺带传给服务端的方式之外，还允许单独的接口来传输或者说更新这个key
      - 因为这个key是敏感信息，所以需要把key进行非对称的公钥加密之后再传输，上面已经说过了
      - 更新key的前提条件是必须登录成功，因为这个key之后会和当前登录用户的token绑定在一起
   - 步骤
     - 随机生成一个16字节的密钥key
     - 通过第一点中获取的公钥和非对称加密算法对key进行加密且base64编码，放入请求的header中，示例：`X-CRYPT-SYMMETRY-KEY: 经过加密的key`
     - 把第一步中返回的非对称加密算法放入header中，示例：`X-CRYPT-ASYMMETRIC-ALGO: sm2_pkcs8_c1c3c2`
     - 发送请求 `POST /security/update_transfer_key`，注意无需body